/* Generated By:JavaCC: Do not edit this line. JavaParser.java */

/* 
 *
 * This file is part of java2XML
 * Copyright (C) Harsh Jain, All Rights Reserved.
 * Email : harsh@harshjain.com			Website : http://www.harshjain.com/
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from the
 * use of this software.
 *
 * Permission is granted to anyone to use this software for any non-commercial 
 * applications freely, subject to the following restriction.
 *
 *  1. The origin of this software must not be misrepresented; you must not
 *     claim that you wrote the original software. If you use this software in
 *     a product, an acknowledgment in the product documentation would be
 *     appreciated but is not required.
 *
 *  2. Altered source versions must be plainly marked as such, and must not be
 *     misrepresented as being the original software.
 *
 *  3. This notice must not be removed or altered from any source distribution.
 *
 * For using this software for commercial purpose please contact the author.
 * 
 *
 */
package toxml;



import java.io.*;
import java.util.LinkedList;
import java.util.Iterator;



/**
 * Grammar to parse Java version 1.5
 * @author Sreenivasa Viswanadha - Simplified and enhanced for 1.5
 */
public class JavaParser implements JavaParserConstants {

	private static final long serialVersionUID = 3L;

   /**
    * Class to hold modifiers.
    */
   static public final class ModifierSet
   {
     /* Definitions of the bits in the modifiers field.  */
     public static final int PUBLIC = 0x0001;
     public static final int PROTECTED = 0x0002;
     public static final int PRIVATE = 0x0004;
     public static final int ABSTRACT = 0x0008;
     public static final int STATIC = 0x0010;
     public static final int FINAL = 0x0020;
     public static final int SYNCHRONIZED = 0x0040;
     public static final int NATIVE = 0x0080;
     public static final int TRANSIENT = 0x0100;
     public static final int VOLATILE = 0x0200;
     public static final int STRICTFP = 0x1000;

     /** A set of accessors that indicate whether the specified modifier
         is in the set. */

     public static boolean isPublic(int modifiers)
     {
       return (modifiers & PUBLIC) != 0;
     }

     public static boolean isProtected(int modifiers)
     {
       return (modifiers & PROTECTED) != 0;
     }

     public static boolean isPrivate(int modifiers)
     {
       return (modifiers & PRIVATE) != 0;
     }

     public static boolean isStatic(int modifiers)
     {
       return (modifiers & STATIC) != 0;
     }

     public static boolean isAbstract(int modifiers)
     {
       return (modifiers & ABSTRACT) != 0;
     }

     public static boolean isFinal(int modifiers)
     {
       return (modifiers & FINAL) != 0;
     }

     public static boolean isNative(int modifiers)
     {
       return (modifiers & NATIVE) != 0;
     }

     public static boolean isStrictfp(int modifiers)
     {
       return (modifiers & STRICTFP) != 0;
     }

     public static boolean isSynchronized(int modifiers)
     {
       return (modifiers & SYNCHRONIZED) != 0;
     }

     public static boolean isTransient(int modifiers)
      {
       return (modifiers & TRANSIENT) != 0;
     }

     public static boolean isVolatile(int modifiers)
     {
       return (modifiers & VOLATILE) != 0;
     }

     /**
      * Removes the given modifier.
      */
     static int removeModifier(int modifiers, int mod)
     {
        return modifiers & ~mod;
     }
   }



    public static IXMLElement convert(Reader javaCode)
   throws JXMLException
   {
       try{
	      JavaParser parser = new JavaParser(javaCode);
	      IXMLElement root = parser.CompilationUnit();
		return root;
       }catch(ParseException e){
		throw new JXMLException(e.getMessage());
       }
   }






   private IXMLElement mergeElemsToBinary(LinkedList elems, LinkedList op){
       IXMLElement previous = (IXMLElement)elems.removeFirst();
       while (elems.size() > 0){
           IXMLElement next = (IXMLElement)elems.removeFirst();
           IXMLElement merge = new XMLElement();
           merge.setName("binary-expr");
           String operator = (String)op.removeFirst();

           merge.setAttribute("op",operator);
           merge.addChild(previous);
           merge.addChild(next);
           previous = merge;
       }
       return previous;
   }

   private void processModifiers(int modifiers, IXMLElement element)
   {
       boolean pri = ModifierSet.isPrivate(modifiers);
       boolean pub = ModifierSet.isPublic(modifiers);
       boolean pro = ModifierSet.isProtected(modifiers);
       if (pri)
           element.setAttribute("visibility","private");
       else if (pub)
           element.setAttribute("visibility","public");
       else if (pro)
           element.setAttribute("visibility","protected");
       else
           element.setAttribute("visibility","protected");
       //set abstract...
       if (ModifierSet.isAbstract(modifiers))
           element.setAttribute("abstract","true");
       if (ModifierSet.isFinal(modifiers))
           element.setAttribute("final","true");
       if (ModifierSet.isStatic(modifiers))
           element.setAttribute("static","true");
       if (ModifierSet.isSynchronized(modifiers))
           element.setAttribute("synchronized","true");


   }

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */
/**
 * Returns the IXMLElement corresponding to java-class-file 
 */
  final public IXMLElement CompilationUnit() throws ParseException {
    IXMLElement javaSourceProgramElem = new XMLElement();
    javaSourceProgramElem.setName("java-class-file");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PACKAGE:
       IXMLElement packageDeclElem;
      packageDeclElem = PackageDeclaration();
       javaSourceProgramElem.addChild(packageDeclElem);
      break;
    default:
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
        ;
        break;
      default:
        break label_1;
      }
              IXMLElement importElem;
      importElem = ImportDeclaration();
              javaSourceProgramElem.addChild(importElem);
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case CLASS:
      case ENUM:
      case FINAL:
      case INTERFACE:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case SEMICOLON:
      case AT:
        ;
        break;
      default:
        break label_2;
      }
              IXMLElement classOrInterfaceElem;
      classOrInterfaceElem = TypeDeclaration();
              javaSourceProgramElem.addChild(classOrInterfaceElem);
    }
    jj_consume_token(0);
      {if (true) return javaSourceProgramElem;}
    throw new Error("Missing return statement in function");
  }

/**
 * Returns the IXMLElement corresponding to a package Decleration
 * @return
 */
  final public IXMLElement PackageDeclaration() throws ParseException {
    IXMLElement packageDeclElem = new XMLElement();
    packageDeclElem.setName("package-decl");
        String name;
    jj_consume_token(PACKAGE);
    name = Name();
    jj_consume_token(SEMICOLON);
        packageDeclElem.setAttribute("name",conv(name));		//conv
        {if (true) return packageDeclElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ImportDeclaration() throws ParseException {
    IXMLElement importElem = new XMLElement();
    importElem.setName("import");
    String name;
    jj_consume_token(IMPORT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      jj_consume_token(STATIC);
                 importElem.setAttribute("static","true");
      break;
    default:
      ;
    }
    name = Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      jj_consume_token(STAR);
                   name += ".*";
      break;
    default:
      ;
    }
    jj_consume_token(SEMICOLON);
                                importElem.setAttribute("module",conv(name));		//conv
                                {if (true) return importElem;}
    throw new Error("Missing return statement in function");
  }

/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 */
  final public int Modifiers() throws ParseException {
   int modifiers = 0;
    label_3:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUBLIC:
        jj_consume_token(PUBLIC);
              modifiers |= ModifierSet.PUBLIC;
        break;
      case STATIC:
        jj_consume_token(STATIC);
              modifiers |= ModifierSet.STATIC;
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
                 modifiers |= ModifierSet.PROTECTED;
        break;
      case PRIVATE:
        jj_consume_token(PRIVATE);
               modifiers |= ModifierSet.PRIVATE;
        break;
      case FINAL:
        jj_consume_token(FINAL);
             modifiers |= ModifierSet.FINAL;
        break;
      case ABSTRACT:
        jj_consume_token(ABSTRACT);
                modifiers |= ModifierSet.ABSTRACT;
        break;
      case SYNCHRONIZED:
        jj_consume_token(SYNCHRONIZED);
                    modifiers |= ModifierSet.SYNCHRONIZED;
        break;
      case NATIVE:
        jj_consume_token(NATIVE);
              modifiers |= ModifierSet.NATIVE;
        break;
      case TRANSIENT:
        jj_consume_token(TRANSIENT);
                 modifiers |= ModifierSet.TRANSIENT;
        break;
      case VOLATILE:
        jj_consume_token(VOLATILE);
                modifiers |= ModifierSet.VOLATILE;
        break;
      case STRICTFP:
        jj_consume_token(STRICTFP);
                modifiers |= ModifierSet.STRICTFP;
        break;
      case AT:
        Annotation();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return modifiers;}
    throw new Error("Missing return statement in function");
  }

/*
 * Declaration syntax follows.
 */
  final public IXMLElement TypeDeclaration() throws ParseException {
   int modifiers;
   IXMLElement typeDeclElem=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case ABSTRACT:
    case CLASS:
    case ENUM:
    case FINAL:
    case INTERFACE:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case AT:
      modifiers = Modifiers();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
      case INTERFACE:
        typeDeclElem = ClassOrInterfaceDeclaration(modifiers);
        break;
      case ENUM:
        EnumDeclaration(modifiers);
        break;
      case AT:
        AnnotationTypeDeclaration(modifiers);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    {if (true) return typeDeclElem;}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * 
 * @param modifiers
 * @return IXMLElement class Or interface IXMLElement 
 */
  final public IXMLElement ClassOrInterfaceDeclaration(int modifiers) throws ParseException {
   boolean isInterface = false;
   IXMLElement classOrInterfaceElem = new XMLElement();
   Token t;
   IXMLElement temp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASS:
      jj_consume_token(CLASS);
      classOrInterfaceElem.setName("class");
      break;
    case INTERFACE:
      jj_consume_token(INTERFACE);
      isInterface = true;
      classOrInterfaceElem.setName("interface");
      if (ModifierSet.isPublic(modifiers))
          classOrInterfaceElem.setAttribute("visibility","public");
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(IDENTIFIER);
      classOrInterfaceElem.setAttribute("name",conv(t.image));		//conv
      processModifiers(modifiers, classOrInterfaceElem);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      temp = TypeParameters();
   classOrInterfaceElem.addChild(temp);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      ExtendsList(isInterface, classOrInterfaceElem);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      ImplementsList(isInterface, classOrInterfaceElem);
      break;
    default:
      ;
    }
    ClassOrInterfaceBody(isInterface, classOrInterfaceElem);
      {if (true) return classOrInterfaceElem;}
    throw new Error("Missing return statement in function");
  }

/**
 * Populates the element with the extendList...
 * 
 * @param isInterface
 * @param element
 */
  final public void ExtendsList(boolean isInterface, IXMLElement element) throws ParseException {
   boolean extendsMoreThanOne = false;
   IXMLElement type = null;
    jj_consume_token(EXTENDS);
    type = ClassOrInterfaceType();
           String name = type.getAttribute("name");
       IXMLElement extend = new XMLElement();
       if (isInterface){
           extend.setName("extend");
           extend.setAttribute("interface",conv(name));		//conv
       }else{
           extend.setName("superclass");
           extend.setAttribute("name",conv(name));			//conv
       }
       element.addChild(extend);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_4;
      }
      jj_consume_token(COMMA);
      type = ClassOrInterfaceType();
            name = type.getAttribute("name");
                extendsMoreThanOne = true;
                IXMLElement extendMore = new XMLElement();
                extendMore.setName("extend");
            extendMore.setAttribute("name",conv(name));		//conv
            element.addChild(extendMore);
    }
      if (extendsMoreThanOne && !isInterface)
         {if (true) throw new ParseException("A class cannot extend more than one other class");}
  }

  final public void ImplementsList(boolean isInterface, IXMLElement element) throws ParseException {
        IXMLElement type;
    jj_consume_token(IMPLEMENTS);
    type = ClassOrInterfaceType();
       String name = type.getAttribute("name");
       IXMLElement implementElem = new XMLElement();
       implementElem.setName("implement");
       implementElem.setAttribute("interface",conv(name));		//conv
       element.addChild(implementElem);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_5;
      }
      jj_consume_token(COMMA);
      type = ClassOrInterfaceType();
           name = type.getAttribute("name");
       IXMLElement implementElemNext = new XMLElement();
       implementElemNext.setName("implement");
       implementElemNext.setAttribute("interface",conv(name));	//conv
       element.addChild(implementElemNext);
    }
      if (isInterface)
         {if (true) throw new ParseException("An interface cannot implement other interfaces");}
  }

/*
 * ditch enums for now...
 */
  final public void EnumDeclaration(int modifiers) throws ParseException {
    jj_consume_token(ENUM);
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      ImplementsList(false, null);
      break;
    default:
      ;
    }
    EnumBody();
  }

  final public void EnumBody() throws ParseException {
    jj_consume_token(LBRACE);
    EnumConstant();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_6;
      }
      jj_consume_token(COMMA);
      EnumConstant();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case IDENTIFIER:
        case LBRACE:
        case SEMICOLON:
        case AT:
        case LT:
          ;
          break;
        default:
          break label_7;
        }
        ClassOrInterfaceBodyDeclaration(false, null);
      }
      break;
    default:
      ;
    }
    jj_consume_token(RBRACE);
  }

  final public void EnumConstant() throws ParseException {
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      Arguments();
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ClassOrInterfaceBody(false, null);
      break;
    default:
      ;
    }
  }

  final public IXMLElement TypeParameters() throws ParseException {
        IXMLElement typeParamElem = new XMLElement();
        typeParamElem.setName("type-parameters");
        IXMLElement temp;
    jj_consume_token(LT);
    temp = TypeParameter();
    typeParamElem.addChild(temp);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_8;
      }
      jj_consume_token(COMMA);
      temp = TypeParameter();
     typeParamElem.addChild(temp);
    }
    jj_consume_token(GT);
    {if (true) return typeParamElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement TypeParameter() throws ParseException {
        IXMLElement typeElem = new XMLElement();
        typeElem.setName("type-parameter");
        Token t;
        IXMLElement temp;
    t = jj_consume_token(IDENTIFIER);
        typeElem.setAttribute("name",conv(t.image));		//conv
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      temp = TypeBound();
        typeElem.addChild(temp);
      break;
    default:
      ;
    }
        {if (true) return typeElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement TypeBound() throws ParseException {
        IXMLElement boundsElem = new XMLElement();
        boundsElem.setName("bounds");
        IXMLElement temp;
    jj_consume_token(EXTENDS);
    temp = ClassOrInterfaceType();
    boundsElem.addChild(temp);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        break label_9;
      }
      jj_consume_token(BIT_AND);
      temp = ClassOrInterfaceType();
      boundsElem.addChild(temp);
    }
        {if (true) return boundsElem;}
    throw new Error("Missing return statement in function");
  }

/**
 * process classOrInterface Body Declaration...
 * 
 * 
 */
  final public void ClassOrInterfaceBody(boolean isInterface, IXMLElement element) throws ParseException {
    jj_consume_token(LBRACE);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case IDENTIFIER:
      case LBRACE:
      case SEMICOLON:
      case AT:
      case LT:
        ;
        break;
      default:
        break label_10;
      }
      ClassOrInterfaceBodyDeclaration(isInterface, element);
    }
    jj_consume_token(RBRACE);
  }

  final public void ClassOrInterfaceBodyDeclaration(boolean isInterface, IXMLElement element) throws ParseException {
   boolean isNestedInterface = false;
   int modifiers;
   IXMLElement temp;
    if (jj_2_4(2)) {
      temp = Initializer();
      element.addChild(temp);
      if (isInterface)
        {if (true) throw new ParseException("An interface cannot have initializers");}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case IDENTIFIER:
      case AT:
      case LT:
        modifiers = Modifiers();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
        case INTERFACE:
          temp = ClassOrInterfaceDeclaration(modifiers);
          System.err.println(temp);
          element.addChild(temp);
          break;
        case ENUM:
          EnumDeclaration(modifiers);
          break;
        default:
          if (jj_2_2(2147483647)) {
            temp = ConstructorDeclaration(modifiers);
       element.addChild(temp);
          } else if (jj_2_3(2147483647)) {
            FieldDeclaration(modifiers, element);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BOOLEAN:
            case BYTE:
            case CHAR:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case SHORT:
            case VOID:
            case IDENTIFIER:
            case LT:
              temp = MethodDeclaration(modifiers);
        	element.addChild(temp);
              break;
            default:
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
    IXMLElement emptyElem = new XMLElement();
    emptyElem.setName("empty");
    element.addChild(emptyElem);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/*
 <!ELEMENT field (type,(array-initializer|%expr-elems;)?)>
 <!ATTLIST field
    name CDATA #REQUIRED
    continued (true|false) #IMPLIED
    %visibility-attribute;
    %mod-final;
    %mod-static;
    %mod-volatile;
    %mod-transient;
    %location-info;>
 */
  final public void FieldDeclaration(int modifiers, IXMLElement element) throws ParseException {
    IXMLElement typeElem;
    IXMLElement fieldElem;
    // Modifiers are already matched in the caller
      typeElem = Type();
      fieldElem = new XMLElement();
      fieldElem.setName("field");
      fieldElem.addChild(XMLHelper.createCopy(typeElem));
    VariableDeclarator(fieldElem);
          processModifiers(modifiers, fieldElem);
      element.addChild(fieldElem);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_11;
      }
      jj_consume_token(COMMA);
              fieldElem = new XMLElement();
              fieldElem.setName("field");

              fieldElem.addChild(XMLHelper.createCopy(typeElem));
      VariableDeclarator(fieldElem);
              processModifiers(modifiers, fieldElem);
              element.addChild(fieldElem);
    }
    jj_consume_token(SEMICOLON);
  }

//variableDecl gets already made element for it..
//this is done because type has to be known before hand...
//	
  final public void VariableDeclarator(IXMLElement variableDeclElem) throws ParseException {
    String name;
    //element to hold the initializer
    IXMLElement variableInitializer;
    IXMLElement typeContainer=variableDeclElem.getFirstChildNamed("type");
    name = VariableDeclaratorId(typeContainer);
      variableDeclElem.setAttribute("name",conv(name));		//conv // Declaracion variable
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      variableInitializer = VariableInitializer();
      variableDeclElem.addChild(variableInitializer);
      break;
    default:
      ;
    }
  }

  final public String VariableDeclaratorId(IXMLElement typeContainer) throws ParseException {
    Token t;
    String name;
    int dimensions = 0;
        String dimensionString = typeContainer.getAttribute("dimensions");
        if (dimensionString!=null){
                dimensions = Integer.parseInt(dimensionString);
        }
    t = jj_consume_token(IDENTIFIER);
      name = t.image;
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        break label_12;
      }
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
              dimensions++;
    }
        if (dimensions>0)
                 typeContainer.setAttribute("dimensions",""+dimensions+"");

     {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement VariableInitializer() throws ParseException {
    IXMLElement variableInitElem;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      variableInitElem = ArrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      variableInitElem = Expression();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return variableInitElem;}
    throw new Error("Missing return statement in function");
  }

/**
 * <!ELEMENT array-initializer (array-initializer|%expr-elems;)*>
 *	<!ATTLIST array-initializer
 *	length CDATA #REQUIRED>
 */
  final public IXMLElement ArrayInitializer() throws ParseException {
    int length = 0;
    IXMLElement temp;
    IXMLElement arrayInitElem = new XMLElement();
    arrayInitElem.setName("array-initializer");
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      temp = VariableInitializer();
        arrayInitElem.addChild(temp);
        length++;
      label_13:
      while (true) {
        if (jj_2_5(2)) {
          ;
        } else {
          break label_13;
        }
        jj_consume_token(COMMA);
        temp = VariableInitializer();
                arrayInitElem.addChild(temp);
                length++;
      }
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      ;
    }
    jj_consume_token(RBRACE);
                        arrayInitElem.setAttribute("length",""+length+"");
                        {if (true) return arrayInitElem;}
    throw new Error("Missing return statement in function");
  }

/*
<!ELEMENT method (type,formal-arguments,throws*,block?)>
<!ATTLIST method 
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute;
    %mod-abstract;
    %mod-final;
    %mod-static;
    %mod-synchronized;
    %mod-volatile;
    %mod-transient;
    %mod-native;
    %location-info;>

*/
  final public IXMLElement MethodDeclaration(int modifiers) throws ParseException {
    IXMLElement methodElem = new XMLElement();
    methodElem.setName("method");

    IXMLElement temp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      temp = TypeParameters();
        methodElem.addChild(temp);
      break;
    default:
      ;
    }
    //TODO
      temp = ResultType();
      methodElem.addChild(temp);
    MethodDeclarator(methodElem);
            processModifiers(modifiers, methodElem);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
      jj_consume_token(THROWS);
        LinkedList l;
      l = NameList();
        Iterator iter = l.iterator();
        while(iter.hasNext()){
            String exceptionName = (String)iter.next();
            IXMLElement exceptionElem = new XMLElement();
            exceptionElem.setName("throws");
            exceptionElem.setAttribute("exception",exceptionName);
            methodElem.addChild(exceptionElem);
        }
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      temp = Block();
                 methodElem.addChild(temp);
      break;
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return methodElem;}
    throw new Error("Missing return statement in function");
  }

  final public void MethodDeclarator(IXMLElement methodElem) throws ParseException {
    Token t;
    IXMLElement temp;
    IXMLElement typeElem = methodElem.getFirstChildNamed("type");
    String d = typeElem.getAttribute("dimensions");
    int dimensions = 0;
    if (d!=null)
        dimensions = Integer.parseInt(d);
    t = jj_consume_token(IDENTIFIER);
   methodElem.setAttribute("name",conv(t.image));		//conv //Declaracion métodos
    temp = FormalParameters();
   methodElem.addChild(temp);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        break label_14;
      }
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
           dimensions++;
    }
        if (dimensions>0)
      typeElem.setAttribute("dimensions",""+dimensions+"");
  }

/*
<!ELEMENT formal-arguments (formal-argument)*>
*/
  final public IXMLElement FormalParameters() throws ParseException {
    IXMLElement formalArgElem = new XMLElement();
    formalArgElem.setName("formal-arguments");
    IXMLElement temp;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      temp = FormalParameter();
      formalArgElem.addChild(temp);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_15;
        }
        jj_consume_token(COMMA);
        temp = FormalParameter();
        formalArgElem.addChild(temp);
      }
      break;
    default:
      ;
    }
    jj_consume_token(RPAREN);
        {if (true) return formalArgElem;}
    throw new Error("Missing return statement in function");
  }

/*
  <!ELEMENT formal-argument (type)>
 	<!ATTLIST formal-argument
    name CDATA #REQUIRED
    id ID #REQUIRED
    %mod-final;>
 */
  final public IXMLElement FormalParameter() throws ParseException {
    IXMLElement formalArgElem = new XMLElement();
    formalArgElem.setName("formal-argument");
    IXMLElement typeElem;
    String varName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINAL:
      jj_consume_token(FINAL);
             formalArgElem.setAttribute("final","true");
      break;
    default:
      ;
    }
    typeElem = Type();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELLIPSIS:
      jj_consume_token(ELLIPSIS);
      break;
    default:
      ;
    }
    varName = VariableDeclaratorId(typeElem);
      formalArgElem.setAttribute("name",conv(varName));		//conv // Declaracion parametros
      formalArgElem.addChild(typeElem);
      {if (true) return formalArgElem;}
    throw new Error("Missing return statement in function");
  }

/*
<!ELEMENT constructor (formal-arguments,throws*,(super-call|this-call)?,(%stmt-elems;)?)>
<!ATTLIST constructor
    name CDATA #REQUIRED
    id ID #REQUIRED
    %visibility-attribute;
    %mod-final;
    %mod-static;
    %mod-synchronized;
    %mod-volatile;
    %mod-transient;
    %mod-native;
    %location-info;>
*/
  final public IXMLElement ConstructorDeclaration(int modifiers) throws ParseException {
    IXMLElement constructorElem = new XMLElement();
    constructorElem.setName("constructor");
    processModifiers(modifiers, constructorElem);
    Token t;
    IXMLElement temp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      temp = TypeParameters();
      constructorElem.addChild(temp);
      break;
    default:
      ;
    }
    // Modifiers matched in the caller
      t = jj_consume_token(IDENTIFIER);
    temp = FormalParameters();
      constructorElem.setAttribute("name",conv(t.image));		//conv //Declaracion constructores
      constructorElem.addChild(temp);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
        LinkedList exceptionList;
      jj_consume_token(THROWS);
      exceptionList = NameList();
        Iterator it = exceptionList.iterator();
        while(it.hasNext()){
            String exceptionName = (String)it.next();
            IXMLElement throwsElem = new XMLElement();
            throwsElem.setName("throws");
            throwsElem.setAttribute("exception",conv(exceptionName));		//conv ...
            constructorElem.addChild(throwsElem);
        }
      break;
    default:
      ;
    }
    jj_consume_token(LBRACE);
    if (jj_2_6(2147483647)) {
      temp = ExplicitConstructorInvocation();
      constructorElem.addChild(temp);
    } else {
      ;
    }
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSERT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case INTERFACE:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
        ;
        break;
      default:
        break label_16;
      }
      BlockStatement(constructorElem);
    }
    jj_consume_token(RBRACE);
       {if (true) return constructorElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ExplicitConstructorInvocation() throws ParseException {
    IXMLElement superOrThisCall = new XMLElement();
    IXMLElement argElem;
    IXMLElement temp;
    if (jj_2_8(2147483647)) {
      jj_consume_token(THIS);
      argElem = Arguments();
      jj_consume_token(SEMICOLON);
      superOrThisCall.setName("this-call");
      superOrThisCall.addChild(argElem);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
        if (jj_2_7(2)) {
          temp = PrimaryExpression();
          jj_consume_token(DOT);
          superOrThisCall.addChild(temp);
        } else {
          ;
        }
        jj_consume_token(SUPER);
        argElem = Arguments();
        jj_consume_token(SEMICOLON);
        superOrThisCall.setName("super-call");
        superOrThisCall.addChild(argElem);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return superOrThisCall;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement Initializer() throws ParseException {
    IXMLElement initializerElement = new XMLElement();
    initializerElement.setName("instance-initializer");
    IXMLElement block;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      jj_consume_token(STATIC);
        initializerElement.setName("static-initializer");
      break;
    default:
      ;
    }
    block = Block();
      initializerElement.addChild(block);
  {if (true) return initializerElement;}
    throw new Error("Missing return statement in function");
  }

/*
 * Type, name and expression syntax follows.
 */
/*
 *  Parsing type
 *  <!ELEMENT type EMPTY>
 *  <!ATTLIST type
 *    primitive CDATA #IMPLIED
 *    name CDATA #REQUIRED
 *    dimensions CDATA #IMPLIED
 *    idref IDREF #IMPLIED>
 */
  final public IXMLElement Type() throws ParseException {
    IXMLElement typeElem;
    if (jj_2_9(2)) {
      typeElem = ReferenceType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        typeElem = PrimitiveType();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
   {if (true) return typeElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ReferenceType() throws ParseException {
    IXMLElement referenceType;
    int dimensions = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
      referenceType = PrimitiveType();
      label_17:
      while (true) {
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
        dimensions++;
        if (jj_2_10(2)) {
          ;
        } else {
          break label_17;
        }
      }
      break;
    case IDENTIFIER:
      referenceType = ClassOrInterfaceType();
      label_18:
      while (true) {
        if (jj_2_11(2)) {
          ;
        } else {
          break label_18;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
        dimensions++;
      }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        if (dimensions>0)
       referenceType.setAttribute("dimensions",""+dimensions+"");

       {if (true) return referenceType;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ClassOrInterfaceType() throws ParseException {
    IXMLElement classOrInterfaceType = new XMLElement();
    classOrInterfaceType.setName("type");
    Token t;
    String name;
    t = jj_consume_token(IDENTIFIER);
      name = t.image;
    if (jj_2_12(2)) {
      TypeArguments(classOrInterfaceType);
    } else {
      ;
    }
    label_19:
    while (true) {
      if (jj_2_13(2)) {
        ;
      } else {
        break label_19;
      }
      jj_consume_token(DOT);
      t = jj_consume_token(IDENTIFIER);
            name += "."+t.image;
      if (jj_2_14(2)) {
        TypeArguments(classOrInterfaceType);
      } else {
        ;
      }
    }
      classOrInterfaceType.setAttribute("name",conv(name));		//conv // Declaracion clase
      {if (true) return classOrInterfaceType;}
    throw new Error("Missing return statement in function");
  }

/*
 * parse typeArguments....
 *  
 */
  final public void TypeArguments(IXMLElement typeElem) throws ParseException {
    IXMLElement temp;
    jj_consume_token(LT);
    temp = TypeArgument();
       typeElem.addChild(temp);
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_20;
      }
      jj_consume_token(COMMA);
      temp = TypeArgument();
                typeElem.addChild(temp);
    }
    jj_consume_token(GT);
  }

/*
 * a type Argument...
 * <!ELEMENT type-argument (type|wildcard)>
 * <!ELEMENT wildcard (bound?)>
 * <!ELEMENT bound (type)>
 * <!ATTLIST bound type (upper|lower) #REQUIRED>
 * 
 */
  final public IXMLElement TypeArgument() throws ParseException {
    IXMLElement typeArgumentElem = new XMLElement();
    typeArgumentElem.setName("type-argument");
    IXMLElement temp=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      temp = ReferenceType();
       typeArgumentElem.addChild(temp);
      break;
    case HOOK:
      jj_consume_token(HOOK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
      case SUPER:
        temp = WildcardBounds();
        break;
      default:
        ;
      }
        IXMLElement wildCard = new XMLElement();
        wildCard.setName("wildcard");
        if (temp!=null){
            //bound exist
            wildCard.addChild(temp);
         }
         typeArgumentElem.addChild(wildCard);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return typeArgumentElem;}
    throw new Error("Missing return statement in function");
  }

/**
 * bound
 * 
 * 
 * @return
 */
  final public IXMLElement WildcardBounds() throws ParseException {
    IXMLElement boundElem = new XMLElement();
    boundElem.setName("bound");
    IXMLElement temp=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      jj_consume_token(EXTENDS);
      temp = ReferenceType();
       boundElem.setAttribute("type","upper");
       boundElem.addChild(temp);
      break;
    case SUPER:
      jj_consume_token(SUPER);
      temp = ReferenceType();
     boundElem.setAttribute("type","lower");
     boundElem.addChild(temp);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return boundElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement PrimitiveType() throws ParseException {
    IXMLElement primitiveTypeElem = new XMLElement();
    primitiveTypeElem.setName("type");
    primitiveTypeElem.setAttribute("primitive","true");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
        primitiveTypeElem.setAttribute("name","boolean");
      break;
    case CHAR:
      jj_consume_token(CHAR);
    primitiveTypeElem.setAttribute("name","char");
      break;
    case BYTE:
      jj_consume_token(BYTE);
    primitiveTypeElem.setAttribute("name","byte");
      break;
    case SHORT:
      jj_consume_token(SHORT);
    primitiveTypeElem.setAttribute("name","short");
      break;
    case INT:
      jj_consume_token(INT);
    primitiveTypeElem.setAttribute("name","int");
      break;
    case LONG:
      jj_consume_token(LONG);
    primitiveTypeElem.setAttribute("name","long");
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
    primitiveTypeElem.setAttribute("name","float");
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
    primitiveTypeElem.setAttribute("name","double");
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return primitiveTypeElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ResultType() throws ParseException {
        IXMLElement resultTypeElem;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VOID:
      jj_consume_token(VOID);
        resultTypeElem = new XMLElement();
        resultTypeElem.setName("type");
        resultTypeElem.setAttribute("name","void");
        resultTypeElem.setAttribute("primitive","true");
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      resultTypeElem = Type();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  {if (true) return resultTypeElem;}
    throw new Error("Missing return statement in function");
  }

  final public String Name() throws ParseException {
    String name = "";
    Token t;
    t = jj_consume_token(IDENTIFIER);
       name += t.image;
    label_21:
    while (true) {
      if (jj_2_15(2)) {
        ;
      } else {
        break label_21;
      }
      jj_consume_token(DOT);
      t = jj_consume_token(IDENTIFIER);
                        name += "."+t.image;
    }
      {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public LinkedList NameList() throws ParseException {
    LinkedList l = new LinkedList();
    String temp;
    temp = Name();
              l.add(temp);
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_22;
      }
      jj_consume_token(COMMA);
      temp = Name();
      l.add(temp);
    }
        {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

/*
 * Expression syntax follows.
 */
  final public IXMLElement Expression() throws ParseException {
    IXMLElement expressionElement;
    boolean isAssignment = false;
    IXMLElement leftElement = null;
    IXMLElement rightElement = null;
    String operator=null;
    leftElement = ConditionalExpression();
    if (jj_2_16(2)) {
      operator = AssignmentOperator();
      rightElement = Expression();
        isAssignment = true;
    } else {
      ;
    }
   if (isAssignment){
       IXMLElement lvalueElement = new XMLElement();
       lvalueElement.setName("lvalue");
       lvalueElement.addChild(leftElement);

       expressionElement = new XMLElement();
       expressionElement.setName("assignment-expr");
       expressionElement.setAttribute("op",operator);
       //this has to be lvalue..
       expressionElement.addChild(lvalueElement);
       //this can be any expression
       expressionElement.addChild(rightElement);
       {if (true) return expressionElement;}
   }else{
       {if (true) return leftElement;}
   }
    throw new Error("Missing return statement in function");
  }

/**
 * There are 12 assignment operators...
 * @return
 */
  final public String AssignmentOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
                           {if (true) return "=";}
      break;
    case STARASSIGN:
      jj_consume_token(STARASSIGN);
                           {if (true) return "*=";}
      break;
    case SLASHASSIGN:
      jj_consume_token(SLASHASSIGN);
                           {if (true) return "/=";}
      break;
    case REMASSIGN:
      jj_consume_token(REMASSIGN);
                           {if (true) return "%=";}
      break;
    case PLUSASSIGN:
      jj_consume_token(PLUSASSIGN);
                           {if (true) return "+=";}
      break;
    case MINUSASSIGN:
      jj_consume_token(MINUSASSIGN);
                           {if (true) return "-=";}
      break;
    case LSHIFTASSIGN:
      jj_consume_token(LSHIFTASSIGN);
                           {if (true) return "menormenor="; }//"<<=";}
      break;
    case RSIGNEDSHIFTASSIGN:
      jj_consume_token(RSIGNEDSHIFTASSIGN);
                           {if (true) return ">>=";}
      break;
    case RUNSIGNEDSHIFTASSIGN:
      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
                           {if (true) return ">>>=";}
      break;
    case ANDASSIGN:
      jj_consume_token(ANDASSIGN);
                           {if (true) return "asp="; }//"&=";}
      break;
    case XORASSIGN:
      jj_consume_token(XORASSIGN);
                           {if (true) return "^=";}
      break;
    case ORASSIGN:
      jj_consume_token(ORASSIGN);
                           {if (true) return "|=";}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * 
 * @return the conditional expression...
 */
  final public IXMLElement ConditionalExpression() throws ParseException {
    IXMLElement conditionalElem;
    IXMLElement conditionalOrElem;
    IXMLElement trueExprElem=null, falseExprElem=null;
    boolean isConditional = false;
    conditionalOrElem = ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      jj_consume_token(HOOK);
      trueExprElem = Expression();
      jj_consume_token(COLON);
      falseExprElem = Expression();
       isConditional = true;
      break;
    default:
      ;
    }
      if (isConditional){
          conditionalElem = new XMLElement();
          conditionalElem.setName("conditional-expr");
          conditionalElem.addChild(conditionalOrElem);
          conditionalElem.addChild(trueExprElem);
          conditionalElem.addChild(falseExprElem);
          {if (true) return conditionalElem;}
      }else{
          {if (true) return conditionalOrElem;}
      }
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ConditionalOrExpression() throws ParseException {
    LinkedList conditionalAndElem=new LinkedList();
    LinkedList operator = new LinkedList();
    IXMLElement temp=null;
    temp = ConditionalAndExpression();
      conditionalAndElem.add(temp);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC_OR:
        ;
        break;
      default:
        break label_23;
      }
      jj_consume_token(SC_OR);
      temp = ConditionalAndExpression();
                  //System.out.println("hello ");
              conditionalAndElem.add(temp);
              operator.add("||");
    }
      {if (true) return mergeElemsToBinary(conditionalAndElem, operator);}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ConditionalAndExpression() throws ParseException {
    LinkedList elemList = new LinkedList();
    LinkedList operator = new LinkedList();
    IXMLElement temp=null;
    temp = InclusiveOrExpression();
      elemList.add(temp);
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC_AND:
        ;
        break;
      default:
        break label_24;
      }
      jj_consume_token(SC_AND);
      temp = InclusiveOrExpression();
                operator.add("_and_");	// aqui estaba el "&&", es lo que se añade al fichero XML
                elemList.add(temp);
    }
      {if (true) return mergeElemsToBinary(elemList, operator);}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement InclusiveOrExpression() throws ParseException {
    LinkedList elemList = new LinkedList();
    LinkedList operator = new LinkedList();
    IXMLElement temp;
    temp = ExclusiveOrExpression();
      elemList.add(temp);
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        ;
        break;
      default:
        break label_25;
      }
      jj_consume_token(BIT_OR);
      temp = ExclusiveOrExpression();
                elemList.add(temp);
                operator.add("|");
    }
      {if (true) return mergeElemsToBinary(elemList, operator);}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ExclusiveOrExpression() throws ParseException {
    LinkedList elemList = new LinkedList();
    LinkedList operator = new LinkedList();
    IXMLElement temp;
    temp = AndExpression();
      elemList.add(temp);
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        break label_26;
      }
      jj_consume_token(XOR);
      temp = AndExpression();
                elemList.add(temp);
                operator.add("^");
    }
      {if (true) return mergeElemsToBinary(elemList, operator);}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement AndExpression() throws ParseException {
    LinkedList elemList = new LinkedList();
    LinkedList operator = new LinkedList();
    IXMLElement temp;
    temp = EqualityExpression();
      elemList.add(temp);
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        break label_27;
      }
      jj_consume_token(BIT_AND);
      temp = EqualityExpression();
                elemList.add(temp);
                operator.add("_and_b_"); // por '&'
    }
      {if (true) return mergeElemsToBinary(elemList, operator);}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement EqualityExpression() throws ParseException {
    IXMLElement temp;
    LinkedList elemList = new LinkedList();
    LinkedList operator = new LinkedList();
    temp = InstanceOfExpression();
      elemList.add(temp);
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        break label_28;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        jj_consume_token(EQ);
                      operator.add("==");
        break;
      case NE:
        jj_consume_token(NE);
                      operator.add("!=");
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      temp = InstanceOfExpression();
                elemList.add(temp);
    }
      {if (true) return mergeElemsToBinary(elemList, operator);}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement InstanceOfExpression() throws ParseException {
    IXMLElement instanceOfElem = new XMLElement();
    instanceOfElem.setName("instanceof-test");
    IXMLElement relationalElem=null;
    IXMLElement type=null;
    boolean isInstanceOf = false;
    relationalElem = RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      jj_consume_token(INSTANCEOF);
      type = Type();
      isInstanceOf = true;
      break;
    default:
      ;
    }
    if (isInstanceOf){
             instanceOfElem.addChild(relationalElem);
             instanceOfElem.addChild(type);
             {if (true) return instanceOfElem;}
    }else
             {if (true) return relationalElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement RelationalExpression() throws ParseException {
    IXMLElement temp=null;
    LinkedList elemList = new LinkedList();
    LinkedList operator = new LinkedList();
    temp = ShiftExpression();
      elemList.add(temp);
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case LE:
      case GE:
      case GT:
        ;
        break;
      default:
        break label_29;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        jj_consume_token(LT);
                      operator.add("menor"); // por '<'
        break;
      case GT:
        jj_consume_token(GT);
                      operator.add(">");
        break;
      case LE:
        jj_consume_token(LE);
                      operator.add("menor="); // por '<='
        break;
      case GE:
        jj_consume_token(GE);
                      operator.add(">=");
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      temp = ShiftExpression();
                elemList.add(temp);
    }
      {if (true) return mergeElemsToBinary(elemList, operator);}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ShiftExpression() throws ParseException {
    IXMLElement temp=null;
    LinkedList elemList = new LinkedList();
    LinkedList operator = new LinkedList();
    String storeOp=null;
    temp = AdditiveExpression();
   elemList.add(temp);
    label_30:
    while (true) {
      if (jj_2_17(1)) {
        ;
      } else {
        break label_30;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
        jj_consume_token(LSHIFT);
                           operator.add("menormenor"); // "<<"
        break;
      default:
        if (jj_2_18(1)) {
          storeOp = RSIGNEDSHIFT();
                           operator.add(storeOp);
        } else if (jj_2_19(1)) {
          storeOp = RUNSIGNEDSHIFT();
                           operator.add(storeOp);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      temp = AdditiveExpression();
                elemList.add(temp);
    }
      {if (true) return mergeElemsToBinary(elemList, operator);}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement AdditiveExpression() throws ParseException {
    IXMLElement temp=null;
    LinkedList elemList = new LinkedList();
    LinkedList operator = new LinkedList();
    temp = MultiplicativeExpression();
      elemList.add(temp);
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        break label_31;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
                      operator.add("+");
        break;
      case MINUS:
        jj_consume_token(MINUS);
                      operator.add("-");
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      temp = MultiplicativeExpression();
                elemList.add(temp);
    }
      {if (true) return mergeElemsToBinary(elemList, operator);}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement MultiplicativeExpression() throws ParseException {
    IXMLElement temp=null;
    LinkedList elemList = new LinkedList();
    LinkedList operator = new LinkedList();
    temp = UnaryExpression();
      elemList.add(temp);
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
      case REM:
        ;
        break;
      default:
        break label_32;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
                            operator.add("*");
        break;
      case SLASH:
        jj_consume_token(SLASH);
                            operator.add("/");
        break;
      case REM:
        jj_consume_token(REM);
                            operator.add("%");
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      temp = UnaryExpression();
                elemList.add(temp);
    }
      {if (true) return mergeElemsToBinary(elemList, operator);}
    throw new Error("Missing return statement in function");
  }

/**
 * 
 * @return unary-expr
 */
  final public IXMLElement UnaryExpression() throws ParseException {
    IXMLElement unaryElem=null;
    IXMLElement temp=null;
    String op=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
                       op="+";
        break;
      case MINUS:
        jj_consume_token(MINUS);
                       op="-";
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      temp = UnaryExpression();
      unaryElem = new XMLElement();
      unaryElem.setName("unary-expr");
      unaryElem.setAttribute("op",op);
      unaryElem.addChild(temp);
      break;
    case INCR:
      unaryElem = PreIncrementExpression();
      break;
    case DECR:
      unaryElem = PreDecrementExpression();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
      unaryElem = UnaryExpressionNotPlusMinus();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return unaryElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement PreIncrementExpression() throws ParseException {
 IXMLElement unaryElem = new XMLElement();
 unaryElem.setName("unary-expr");
 unaryElem.setAttribute("post","false");
 unaryElem.setAttribute("op","++");
 IXMLElement temp=null;
    jj_consume_token(INCR);
    temp = PrimaryExpression();
      unaryElem.addChild(temp);
      {if (true) return unaryElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement PreDecrementExpression() throws ParseException {
    IXMLElement unaryElem = new XMLElement();
    unaryElem.setName("unary-expr");
    unaryElem.setAttribute("post","false");
    unaryElem.setAttribute("op","--");
    IXMLElement temp=null;
    jj_consume_token(DECR);
    temp = PrimaryExpression();
      unaryElem.addChild(temp);
      {if (true) return unaryElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement UnaryExpressionNotPlusMinus() throws ParseException {
    IXMLElement unaryExprElem=null;
    IXMLElement temp=null;
    String op=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        jj_consume_token(TILDE);
        op="~";
        break;
      case BANG:
        jj_consume_token(BANG);
                       op="!";
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      temp = UnaryExpression();
      unaryExprElem = new XMLElement();
      unaryExprElem.setName("unary-expr");
      unaryExprElem.setAttribute("op",op);
      unaryExprElem.addChild(temp);
      break;
    default:
      if (jj_2_20(2147483647)) {
        unaryExprElem = CastExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
          unaryExprElem = PostfixExpression();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
        {if (true) return unaryExprElem;}
    throw new Error("Missing return statement in function");
  }

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
  final public void CastLookahead() throws ParseException {
    if (jj_2_21(2)) {
      jj_consume_token(LPAREN);
      PrimitiveType();
    } else if (jj_2_22(2147483647)) {
      jj_consume_token(LPAREN);
      Type();
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        Type();
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TILDE:
          jj_consume_token(TILDE);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          break;
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case THIS:
          jj_consume_token(THIS);
          break;
        case SUPER:
          jj_consume_token(SUPER);
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        case FALSE:
        case NULL:
        case TRUE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
          Literal();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/**
 * parse postfix unary-expr
 * @return
 */
  final public IXMLElement PostfixExpression() throws ParseException {
    IXMLElement unaryExpr = null;
    IXMLElement temp;
    String op=null;
    boolean isPostfix=false;
    temp = PrimaryExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
    case DECR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
        jj_consume_token(INCR);
                   isPostfix=true;op="++";
        break;
      case DECR:
        jj_consume_token(DECR);
                   isPostfix=true;op="--";
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
    if (isPostfix){
       unaryExpr = new XMLElement();
       unaryExpr.setName("unary-expr");
       unaryExpr.setAttribute("post","true");
       unaryExpr.setAttribute("op",op);
       unaryExpr.addChild(temp);
       {if (true) return unaryExpr;}
    }else{
       {if (true) return temp;}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <!ELEMENT cast-expr (type,(%expr-elems;))>
 * @return 
 */
  final public IXMLElement CastExpression() throws ParseException {
    IXMLElement castExprElem = new XMLElement();
    castExprElem.setName("cast-expr");
    IXMLElement typeElem = null;
    IXMLElement exprElem = null;
    if (jj_2_23(2147483647)) {
      jj_consume_token(LPAREN);
      typeElem = Type();
      jj_consume_token(RPAREN);
      exprElem = UnaryExpression();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        typeElem = Type();
        jj_consume_token(RPAREN);
        exprElem = UnaryExpressionNotPlusMinus();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      castExprElem.addChild(typeElem);
      castExprElem.addChild(exprElem);
      {if (true) return castExprElem;}
    throw new Error("Missing return statement in function");
  }

/**
 * parses the primary expression....
 * @return
 */
  final public IXMLElement PrimaryExpression() throws ParseException {
    IXMLElement primaryElement;
    primaryElement = PrimaryPrefix();
    label_33:
    while (true) {
      if (jj_2_24(2)) {
        ;
      } else {
        break label_33;
      }
      primaryElement = PrimarySuffix(primaryElement);
    }
      {if (true) return primaryElement;}
    throw new Error("Missing return statement in function");
  }

  final public void MemberSelector() throws ParseException {
    jj_consume_token(DOT);
    TypeArguments(null);
    jj_consume_token(IDENTIFIER);
  }

  final public IXMLElement PrimaryPrefix() throws ParseException {
    IXMLElement prefixElement;
    Token t;
    IXMLElement temp;
        IXMLElement typeElem;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      prefixElement = Literal();
      break;
    case THIS:
      jj_consume_token(THIS);
      prefixElement = new XMLElement();
      prefixElement.setName("this");
      break;
    case SUPER:
      jj_consume_token(SUPER);
      jj_consume_token(DOT);
      t = jj_consume_token(IDENTIFIER);
      IXMLElement superElem = new XMLElement();
      superElem.setName("super");
      IXMLElement fieldAccess = new XMLElement();
      fieldAccess.setName("field-access");
      fieldAccess.setAttribute("field",conv(t.image));		//conv
      fieldAccess.addChild(superElem);
      prefixElement = fieldAccess;
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      temp = Expression();
      jj_consume_token(RPAREN);
    IXMLElement parenElement = new XMLElement();
    parenElement.setName("paren");
    parenElement.addChild(temp);
    prefixElement = parenElement;
      break;
    case NEW:
      prefixElement = AllocationExpression();
      break;
    default:
      if (jj_2_25(2147483647)) {
        typeElem = ResultType();
        jj_consume_token(DOT);
        jj_consume_token(CLASS);
    IXMLElement fieldAccess2 = new XMLElement();
    fieldAccess2.setName("field-access");
    fieldAccess2.setAttribute("field", "class");
    fieldAccess2.addChild(typeElem);
    prefixElement = fieldAccess2;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          t = jj_consume_token(IDENTIFIER);
    prefixElement = new XMLElement();
    prefixElement.setName("var-ref");
    prefixElement.setAttribute("name",conv(t.image));		//conv // Uso variable
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
        {if (true) return prefixElement;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement PrimarySuffix(IXMLElement prefixElement) throws ParseException {
    IXMLElement suffixElement=null;
    Token t=null;
    IXMLElement temp;
    if (jj_2_26(2)) {
      jj_consume_token(DOT);
      jj_consume_token(THIS);
      suffixElement = new XMLElement();
      suffixElement.setName("field-access");
      suffixElement.setAttribute("field","this");
      suffixElement.addChild(prefixElement);
    } else if (jj_2_27(2)) {
      jj_consume_token(DOT);
      temp = AllocationExpression();

    } else if (jj_2_28(3)) {
      MemberSelector();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        jj_consume_token(LBRACKET);
        temp = Expression();
        jj_consume_token(RBRACKET);
    suffixElement = new XMLElement();
    suffixElement.setName("array-ref");
    IXMLElement baseElem = new XMLElement();
    baseElem.setName("base");
    baseElem.addChild(prefixElement);
    IXMLElement offsetElem = new XMLElement();
    offsetElem.setName("offset");
    offsetElem.addChild(temp);
    suffixElement.addChild(baseElem);
    suffixElement.addChild(offsetElem);
        break;
      case DOT:
        jj_consume_token(DOT);
        t = jj_consume_token(IDENTIFIER);
        suffixElement = new XMLElement();
        suffixElement.setName("field-access");
        suffixElement.setAttribute("field",conv(t.image));		//conv
        suffixElement.addChild(prefixElement);
        break;
      case LPAREN:
        temp = Arguments();
        /*
    	 * well so the argument is called... now previous element's root should be 
    	 * a field-access or a var-ref 
    	 * else we don't know what to do...
    	 */
    suffixElement = new XMLElement();
    suffixElement.setName("send");

    if (prefixElement.getName().equals("field-access")){
        //modify this....
        suffixElement.setAttribute("message",prefixElement.getAttribute("field"));
        IXMLElement targetElem = new XMLElement();
        targetElem.setName("target");
        targetElem.addChild(prefixElement.getChildAtIndex(0));
        suffixElement.addChild(targetElem);
        suffixElement.addChild(temp);

    }else if (prefixElement.getName().equals("var-ref")){
        suffixElement.setAttribute("message", prefixElement.getAttribute("name"));
        suffixElement.addChild(temp);
    }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return suffixElement;}
    throw new Error("Missing return statement in function");
  }

/**
 * 
 * @return the IXMLElement corresponding to the literal
 */
  final public IXMLElement Literal() throws ParseException {
    Token t;
    IXMLElement literalElement = new XMLElement();
    String temp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
      literalElement.setName("literal-number");
      literalElement.setAttribute("kind","int");//interger
      literalElement.setAttribute("value",t.image);
      break;
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
    literalElement.setName("literal-number");
    literalElement.setAttribute("kind","float");
    literalElement.setAttribute("value",t.image);
      break;
    case CHARACTER_LITERAL:
      t = jj_consume_token(CHARACTER_LITERAL);
    literalElement.setName("literal-char");
    literalElement.setAttribute("value",t.image);
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
    literalElement.setName("literal-string");

	// Añadido para quitar las comillas de la propia cadena de caracteres
	String cadena_aux=t.image.substring(1,t.image.length()-1);

	literalElement.setAttribute("value",conv(cadena_aux));	//convString

    //literalElement.setAttribute("value",t.image.substring(1,t.image.length()-1));
      break;
    case FALSE:
    case TRUE:
      temp = BooleanLiteral();
    literalElement.setName("literal-boolean");
    literalElement.setAttribute("value", temp);
      break;
    case NULL:
      NullLiteral();
    literalElement.setName("literal-null");
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return literalElement;}
    throw new Error("Missing return statement in function");
  }

  final public String BooleanLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
        {if (true) return "true";}
      break;
    case FALSE:
      jj_consume_token(FALSE);
        {if (true) return "false";}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void NullLiteral() throws ParseException {
    jj_consume_token(NULL);
  }

/**
 * 
 * @return an arguments type element
 */
  final public IXMLElement Arguments() throws ParseException {
    IXMLElement argumentElem = new XMLElement();
    argumentElem.setName("arguments");
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      ArgumentList(argumentElem);
      break;
    default:
      ;
    }
    jj_consume_token(RPAREN);
      {if (true) return argumentElem;}
    throw new Error("Missing return statement in function");
  }

  final public void ArgumentList(IXMLElement argumentElem) throws ParseException {
    IXMLElement temp;
    temp = Expression();
      argumentElem.addChild(temp);
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_34;
      }
      jj_consume_token(COMMA);
      temp = Expression();
                argumentElem.addChild(temp);
    }
  }

  final public IXMLElement AllocationExpression() throws ParseException {
    IXMLElement newElement;//can be new or new-array

        IXMLElement typeElem;
    if (jj_2_29(2)) {
      jj_consume_token(NEW);
      typeElem = PrimitiveType();
      newElement = new XMLElement();
      newElement.setName("new-array");
      newElement.addChild(typeElem);
      ArrayDimsAndInits(newElement);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEW:
        jj_consume_token(NEW);
        typeElem = ClassOrInterfaceType();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          TypeArguments(typeElem);
          break;
        default:
          ;
        }
        newElement = new XMLElement();
        //newElement.setName("new-array"); cant decide now
        newElement.addChild(typeElem);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ArrayDimsAndInits(newElement);
          newElement.setName("new-array");
          break;
        case LPAREN:
        IXMLElement argumentsElem;
        IXMLElement anonymousElem = null;
          argumentsElem = Arguments();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
        anonymousElem = new XMLElement();
        anonymousElem.setName("anonymous-class");
            ClassOrInterfaceBody(false, anonymousElem);
            break;
          default:
            ;
          }
          newElement.setName("new");
          newElement.addChild(argumentsElem);
          if (anonymousElem!=null)
                newElement.addChild(anonymousElem);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return newElement;}
    throw new Error("Missing return statement in function");
  }

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
  final public void ArrayDimsAndInits(IXMLElement element) throws ParseException {
    IXMLElement temp;
    int dimensions = 0;
    if (jj_2_32(2)) {
      label_35:
      while (true) {
        jj_consume_token(LBRACKET);
        temp = Expression();
        jj_consume_token(RBRACKET);
                IXMLElement dimElem = new XMLElement();
                dimElem.setName("dim-expr");
                dimElem.addChild(temp);
                element.addChild(dimElem);
                dimensions++;
        if (jj_2_30(2)) {
          ;
        } else {
          break label_35;
        }
      }
      label_36:
      while (true) {
        if (jj_2_31(2)) {
          ;
        } else {
          break label_36;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                IXMLElement dimElem = new XMLElement();
                dimElem.setName("dim-expr");
                element.addChild(dimElem);
                dimensions++;
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        label_37:
        while (true) {
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
              IXMLElement dimElem = new XMLElement();
              dimElem.setName("dim-expr");
              element.addChild(dimElem);
              dimensions++;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            ;
            break;
          default:
            break label_37;
          }
        }
        temp = ArrayInitializer();
        element.addChild(temp);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    element.setAttribute("dimensions",""+dimensions+"");
  }

/*
 * Statement syntax follows.
 */
  final public IXMLElement Statement() throws ParseException {
    IXMLElement statement=null;
    if (jj_2_33(2)) {
      statement = LabeledStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSERT:
        statement = AssertStatement();
        break;
      case LBRACE:
        statement = Block();
        break;
      case SEMICOLON:
        statement = EmptyStatement();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case INCR:
      case DECR:
        statement = StatementExpression();
        jj_consume_token(SEMICOLON);
        break;
      case SWITCH:
        statement = SwitchStatement();
        break;
      case IF:
        statement = IfStatement();
        break;
      case WHILE:
        statement = WhileStatement();
        break;
      case DO:
        statement = DoStatement();
        break;
      case FOR:
        statement = ForStatement();
        break;
      case BREAK:
        statement = BreakStatement();
        break;
      case CONTINUE:
        statement = ContinueStatement();
        break;
      case RETURN:
        statement = ReturnStatement();
        break;
      case THROW:
        statement = ThrowStatement();
        break;
      case SYNCHRONIZED:
        statement = SynchronizedStatement();
        break;
      case TRY:
        statement = TryStatement();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return statement;}
    throw new Error("Missing return statement in function");
  }

/**
 *  <!ELEMENT assert (condition,error-message?)>
 *  <!ELEMENT condition (%expr-elems;)>
 *  <!ELEMENT error-message (%expr-elems;)>
 */
  final public IXMLElement AssertStatement() throws ParseException {
    IXMLElement assertElem = new XMLElement();
    assertElem.setName("assert");
    IXMLElement conditionElem = new XMLElement();
    conditionElem.setName("condition");
    IXMLElement expr1, expr2;
    jj_consume_token(ASSERT);
    expr1 = Expression();
      conditionElem.addChild(expr1);
      assertElem.addChild(conditionElem);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      expr2 = Expression();
      IXMLElement errorElem = new XMLElement();
      errorElem.setName("error-message");
      errorElem.addChild(expr2);
      assertElem.addChild(errorElem);
      break;
    default:
      ;
    }
    jj_consume_token(SEMICOLON);
                                                            {if (true) return assertElem;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parse the labeled Statement 
 */
  final public IXMLElement LabeledStatement() throws ParseException {
    Token t;
    IXMLElement statementElem;
    t = jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    statementElem = Statement();
      IXMLElement labelElem = new XMLElement();
      labelElem.setName("label");
      labelElem.setAttribute("name",conv(t.image));		//conv
      labelElem.addChild(statementElem);
      {if (true) return labelElem;}
    throw new Error("Missing return statement in function");
  }

/**
 * pass element to Block as there are many elements to be added
 * @param element
 * @return
 */
  final public IXMLElement Block() throws ParseException {
    IXMLElement block = new XMLElement();
    block.setName("block");
    jj_consume_token(LBRACE);
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSERT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case INTERFACE:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
        ;
        break;
      default:
        break label_38;
      }
      BlockStatement(block);
    }
    jj_consume_token(RBRACE);
        {if (true) return block;}
    throw new Error("Missing return statement in function");
  }

/**
 * Block statement...
 * A block consists of many such block statements.....
 *
 */
  final public void BlockStatement(IXMLElement element) throws ParseException {
    boolean isFinal = false;
    IXMLElement temp;
    if (jj_2_34(2147483647)) {
      LocalVariableDeclaration(element);
      jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSERT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
        temp = Statement();
                if (temp!=null)
       element.addChild(temp);
        break;
      case CLASS:
      case INTERFACE:
        ClassOrInterfaceDeclaration(0);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void LocalVariableDeclaration(IXMLElement element) throws ParseException {
    IXMLElement temp;
    boolean isFinal=false;
    IXMLElement type;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINAL:
      jj_consume_token(FINAL);
        isFinal = true;
      break;
    default:
      ;
    }
    type = Type();
      temp=new XMLElement();
      temp.setName("local-variable");
      temp.addChild(XMLHelper.createCopy(type));
      if (isFinal){
          temp.setAttribute("final","true");
      }
    VariableDeclarator(temp);
      element.addChild(temp);
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_39;
      }
      jj_consume_token(COMMA);
                temp = new XMLElement();
                temp.setName("local-variable");
                temp.addChild(XMLHelper.createCopy(type));
                if (isFinal){
                    temp.setAttribute("final","true");
                }
                temp.setAttribute("continued","true");
      VariableDeclarator(temp);
                element.addChild(temp);
    }
  }

  final public IXMLElement EmptyStatement() throws ParseException {
    IXMLElement emptyElem = new XMLElement();
    emptyElem.setName("empty");
    jj_consume_token(SEMICOLON);
        {if (true) return emptyElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement StatementExpression() throws ParseException {
    IXMLElement statementExpressionElem=null;
    IXMLElement temp=null;
    String operator=null;
    IXMLElement rightExpr = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
      statementExpressionElem = PreIncrementExpression();
      break;
    case DECR:
      statementExpressionElem = PreDecrementExpression();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
      temp = PrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
      case INCR:
      case DECR:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case LSHIFTASSIGN:
      case RSIGNEDSHIFTASSIGN:
      case RUNSIGNEDSHIFTASSIGN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INCR:
          jj_consume_token(INCR);
        statementExpressionElem = new XMLElement();
        statementExpressionElem.setName("unary-expr");
        statementExpressionElem.setAttribute("op","++");
        statementExpressionElem.setAttribute("post","true");
        statementExpressionElem.addChild(temp);
          break;
        case DECR:
          jj_consume_token(DECR);
        statementExpressionElem = new XMLElement();
        statementExpressionElem.setName("unary-expr");
        statementExpressionElem.setAttribute("op","--");
        statementExpressionElem.setAttribute("post","true");
        statementExpressionElem.addChild(temp);
          break;
        case ASSIGN:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case LSHIFTASSIGN:
        case RSIGNEDSHIFTASSIGN:
        case RUNSIGNEDSHIFTASSIGN:
          operator = AssignmentOperator();
          rightExpr = Expression();
      statementExpressionElem = new XMLElement();
      statementExpressionElem.setName("assignment-expr");
      statementExpressionElem.setAttribute("op",operator);
      IXMLElement lvalueElem = new XMLElement();
      lvalueElem.setName("lvalue");
      lvalueElem.addChild(temp);
      statementExpressionElem.addChild(lvalueElem);
      statementExpressionElem.addChild(rightExpr);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (statementExpressionElem==null)
                        statementExpressionElem = temp;
        {if (true) return statementExpressionElem;}
    throw new Error("Missing return statement in function");
  }

/**
 *  <!ELEMENT switch ((%expr-elems;),switch-block+)>
 *  <!ELEMENT switch-block ((case|default-case)+,(%stmt-elems;)*)>
 *  <!ELEMENT case (%expr-elems;)>
 *  <!ELEMENT default-case EMPTY>
 */
  final public IXMLElement SwitchStatement() throws ParseException {
    IXMLElement switchElem = new XMLElement();
    switchElem.setName("switch");
    IXMLElement exprElem;
    jj_consume_token(SWITCH);
    jj_consume_token(LPAREN);
    exprElem = Expression();
    jj_consume_token(RPAREN);
    jj_consume_token(LBRACE);
      switchElem.addChild(exprElem);
    label_40:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
      case _DEFAULT:
        ;
        break;
      default:
        break label_40;
      }
                IXMLElement switchBlockElem = new XMLElement();
                switchBlockElem.setName("switch-block");
                IXMLElement caseElem;
      caseElem = SwitchLabel();
                switchBlockElem.addChild(caseElem);
      label_41:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSERT:
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CLASS:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case FALSE:
        case FINAL:
        case FLOAT:
        case FOR:
        case IF:
        case INT:
        case INTERFACE:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case THROW:
        case TRUE:
        case TRY:
        case VOID:
        case WHILE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case SEMICOLON:
        case INCR:
        case DECR:
          ;
          break;
        default:
          break label_41;
        }
        BlockStatement(switchBlockElem);
      }
        switchElem.addChild(switchBlockElem);
    }
    jj_consume_token(RBRACE);
        {if (true) return switchElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement SwitchLabel() throws ParseException {
    IXMLElement caseElem = new XMLElement();
    IXMLElement temp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE:
      jj_consume_token(CASE);
      temp = Expression();
      jj_consume_token(COLON);
      caseElem.setName("case");
      caseElem.addChild(temp);
      break;
    case _DEFAULT:
      jj_consume_token(_DEFAULT);
      jj_consume_token(COLON);
    caseElem.setName("default-case");
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return caseElem;}
    throw new Error("Missing return statement in function");
  }

/**
 *<!ELEMENT if (test,true-case,false-case?)>
 */
  final public IXMLElement IfStatement() throws ParseException {
    IXMLElement ifElem = new XMLElement();
    IXMLElement temp;
    ifElem.setName("if");
    jj_consume_token(IF);
    jj_consume_token(LPAREN);
    temp = Expression();
      IXMLElement testElem = new XMLElement();
      testElem.setName("test");
      testElem.addChild(temp);
      ifElem.addChild(testElem);
    jj_consume_token(RPAREN);
    temp = Statement();
      IXMLElement trueElem = new XMLElement();
      trueElem.setName("true-case");
      trueElem.addChild(temp);
      ifElem.addChild(trueElem);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      temp = Statement();
      IXMLElement falseElem = new XMLElement();
      falseElem.setName("false-case");
      falseElem.addChild(temp);
      ifElem.addChild(falseElem);
      break;
    default:
      ;
    }
        {if (true) return ifElem;}
    throw new Error("Missing return statement in function");
  }

/**
 *<!ELEMENT loop (init*,test?,update*,(%stmt-elems;)?)>
 * <!ATTLIST loop
 *  kind (for|while|do) #REQUIRED
 *  %location-info;>
 *<!ELEMENT init (local-variable|%expr-elems;)*>
 *<!ELEMENT update (%expr-elems;)>
 *
 * 
 */
  final public IXMLElement WhileStatement() throws ParseException {
    IXMLElement loopElem = new XMLElement();
    loopElem.setName("loop");
    loopElem.setAttribute("kind","while");
    IXMLElement temp;
    jj_consume_token(WHILE);
    jj_consume_token(LPAREN);
    temp = Expression();
      IXMLElement testElem = new XMLElement();
      testElem.setName("test");
      testElem.addChild(temp);
      loopElem.addChild(testElem);
    jj_consume_token(RPAREN);
    temp = Statement();
      loopElem.addChild(temp);
        {if (true) return loopElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement DoStatement() throws ParseException {
    IXMLElement loopElem = new XMLElement();
    loopElem.setName("loop");
    loopElem.setAttribute("kind","do");
    IXMLElement temp1;
    IXMLElement temp2;
    jj_consume_token(DO);
    temp1 = Statement();
    jj_consume_token(WHILE);
    jj_consume_token(LPAREN);
    temp2 = Expression();
    jj_consume_token(RPAREN);
    jj_consume_token(SEMICOLON);
      IXMLElement testElem = new XMLElement();
      testElem.setName("test");
      testElem.addChild(temp2);
      loopElem.addChild(testElem);
      loopElem.addChild(temp1);
      {if (true) return loopElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ForStatement() throws ParseException {
    IXMLElement loopElem = new XMLElement();
    loopElem.setName("loop");
    loopElem.setAttribute("kind","for");
    IXMLElement temp;
    jj_consume_token(FOR);
    jj_consume_token(LPAREN);
    if (jj_2_35(2147483647)) {
      Type();
      jj_consume_token(IDENTIFIER);
      jj_consume_token(COLON);
      Expression();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case SEMICOLON:
      case INCR:
      case DECR:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FINAL:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case INCR:
        case DECR:
          temp = ForInit();
                      loopElem.addChild(temp);
          break;
        default:
          ;
        }
        jj_consume_token(SEMICOLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case BANG:
        case TILDE:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
          temp = Expression();
           IXMLElement testElem = new XMLElement();
           testElem.setName("test");
           testElem.addChild(temp);
           loopElem.addChild(testElem);
          break;
        default:
          ;
        }
        jj_consume_token(SEMICOLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case INCR:
        case DECR:
          temp = ForUpdate();
                             loopElem.addChild(temp);
          break;
        default:
          ;
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RPAREN);
    temp = Statement();
      loopElem.addChild(temp);
      {if (true) return loopElem;}
    throw new Error("Missing return statement in function");
  }

  final public IXMLElement ForInit() throws ParseException {
    IXMLElement initElem = new XMLElement();
    initElem.setName("init");
    if (jj_2_36(2147483647)) {
      LocalVariableDeclaration(initElem);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case INCR:
      case DECR:
        StatementExpressionList(initElem);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return initElem;}
    throw new Error("Missing return statement in function");
  }

  final public void StatementExpressionList(IXMLElement element) throws ParseException {
    IXMLElement temp;
    temp = StatementExpression();
      element.addChild(temp);
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_42;
      }
      jj_consume_token(COMMA);
      temp = StatementExpression();
                element.addChild(temp);
    }
  }

  final public IXMLElement ForUpdate() throws ParseException {
    IXMLElement updateElem = new XMLElement();
    updateElem.setName("update");
    StatementExpressionList(updateElem);
      {if (true) return updateElem;}
    throw new Error("Missing return statement in function");
  }

/*
<!ELEMENT break EMPTY>
<!ATTLIST break
    targetname CDATA #IMPLIED>
    */
  final public IXMLElement BreakStatement() throws ParseException {
    IXMLElement breakElem = new XMLElement();
    breakElem.setName("break");
    Token t;
    jj_consume_token(BREAK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      breakElem.setAttribute("targetname",conv(t.image));		//conv
      break;
    default:
      ;
    }
    jj_consume_token(SEMICOLON);
    {if (true) return breakElem;}
    throw new Error("Missing return statement in function");
  }

/*
<!ELEMENT continue EMPTY>
<!ATTLIST continue
    targetname CDATA #IMPLIED>
*/
  final public IXMLElement ContinueStatement() throws ParseException {
    IXMLElement continueElem = new XMLElement();
    continueElem.setName("continue");
    Token t;
    jj_consume_token(CONTINUE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      continueElem.setAttribute("targetname",conv(t.image));		//conv
      break;
    default:
      ;
    }
    jj_consume_token(SEMICOLON);
                        {if (true) return continueElem;}
    throw new Error("Missing return statement in function");
  }

/*
<!ELEMENT return (%expr-elems;)?>
*/
  final public IXMLElement ReturnStatement() throws ParseException {
    IXMLElement returnElem = new XMLElement();
    returnElem.setName("return");
    IXMLElement exprElem;
    jj_consume_token(RETURN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      exprElem = Expression();
      returnElem.addChild(exprElem);
      break;
    default:
      ;
    }
    jj_consume_token(SEMICOLON);
    {if (true) return returnElem;}
    throw new Error("Missing return statement in function");
  }

/*
<!ELEMENT throw (%expr-elems;)> 
 */
  final public IXMLElement ThrowStatement() throws ParseException {
    IXMLElement throwElem = new XMLElement();
    throwElem.setName("throw");
    IXMLElement exprElem;
    jj_consume_token(THROW);
    exprElem = Expression();
    jj_consume_token(SEMICOLON);
      throwElem.addChild(exprElem);
      {if (true) return throwElem;}
    throw new Error("Missing return statement in function");
  }

/*
 <!ELEMENT synchronized (expr,block)>
<!ELEMENT expr (%expr-elems;)>
 */
  final public IXMLElement SynchronizedStatement() throws ParseException {
    IXMLElement syncElem = new XMLElement();
    syncElem.setName("synchronized");
    IXMLElement temp;
    jj_consume_token(SYNCHRONIZED);
    jj_consume_token(LPAREN);
    temp = Expression();
    IXMLElement exprElem = new XMLElement();
    exprElem.setName("expr");
    exprElem.addChild(temp);
    syncElem.addChild(exprElem);
    jj_consume_token(RPAREN);
    temp = Block();
    syncElem.addChild(temp);
    {if (true) return syncElem;}
    throw new Error("Missing return statement in function");
  }

/*
<!ELEMENT try ((%stmt-elems;),catch*,finally?)>
<!ELEMENT catch (formal-argument,(%stmt-elems;)?)>
<!ELEMENT finally (%stmt-elems;)>
*/
  final public IXMLElement TryStatement() throws ParseException {
    IXMLElement tryElem = new XMLElement();
    tryElem.setName("try");
    IXMLElement temp;
    jj_consume_token(TRY);
    temp = Block();
      tryElem.addChild(temp);
    label_43:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CATCH:
        ;
        break;
      default:
        break label_43;
      }
      IXMLElement catchElem = new XMLElement();
      catchElem.setName("catch");
      jj_consume_token(CATCH);
      jj_consume_token(LPAREN);
      temp = FormalParameter();
      catchElem.addChild(temp);
      jj_consume_token(RPAREN);
      temp = Block();
      catchElem.addChild(temp);
      tryElem.addChild(catchElem);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINALLY:
       IXMLElement finallyElem = new XMLElement();
       finallyElem.setName("finally");
      jj_consume_token(FINALLY);
      temp = Block();
        finallyElem.addChild(temp);
        tryElem.addChild(finallyElem);
      break;
    default:
      ;
    }
      if (tryElem.getChildrenCount()==0)
          {if (true) throw new ParseException("try should end with atleast one catch or one finally");}
      {if (true) return tryElem;}
    throw new Error("Missing return statement in function");
  }

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */
  final public String RUNSIGNEDSHIFT() throws ParseException {
    if (getToken(1).kind == GT &&
                    ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(GT);
    jj_consume_token(GT);
    jj_consume_token(GT);
      {if (true) return ">>>";}
    throw new Error("Missing return statement in function");
  }

  final public String RSIGNEDSHIFT() throws ParseException {
    if (getToken(1).kind == GT &&
                    ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(GT);
    jj_consume_token(GT);
      {if (true) return ">>";}
    throw new Error("Missing return statement in function");
  }

/* Annotation syntax follows. */
  final public void Annotation() throws ParseException {
    if (jj_2_37(2147483647)) {
      NormalAnnotation();
    } else if (jj_2_38(2147483647)) {
      SingleMemberAnnotation();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AT:
        MarkerAnnotation();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void NormalAnnotation() throws ParseException {
    jj_consume_token(AT);
    Name();
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      MemberValuePairs();
      break;
    default:
      ;
    }
    jj_consume_token(RPAREN);
  }

  final public void MarkerAnnotation() throws ParseException {
    jj_consume_token(AT);
    Name();
  }

  final public void SingleMemberAnnotation() throws ParseException {
    jj_consume_token(AT);
    Name();
    jj_consume_token(LPAREN);
    MemberValue();
    jj_consume_token(RPAREN);
  }

  final public void MemberValuePairs() throws ParseException {
    MemberValuePair();
    label_44:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_44;
      }
      jj_consume_token(COMMA);
      MemberValuePair();
    }
  }

  final public void MemberValuePair() throws ParseException {
    jj_consume_token(IDENTIFIER);
    jj_consume_token(ASSIGN);
    MemberValue();
  }

  final public void MemberValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AT:
      Annotation();
      break;
    case LBRACE:
      MemberValueArrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      ConditionalExpression();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void MemberValueArrayInitializer() throws ParseException {
    jj_consume_token(LBRACE);
    MemberValue();
    label_45:
    while (true) {
      if (jj_2_39(2)) {
        ;
      } else {
        break label_45;
      }
      jj_consume_token(COMMA);
      MemberValue();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      ;
    }
    jj_consume_token(RBRACE);
  }

/* Annotation Types. */
  final public void AnnotationTypeDeclaration(int modifiers) throws ParseException {
    jj_consume_token(AT);
    jj_consume_token(INTERFACE);
    jj_consume_token(IDENTIFIER);
    AnnotationTypeBody();
  }

  final public void AnnotationTypeBody() throws ParseException {
    jj_consume_token(LBRACE);
    label_46:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case IDENTIFIER:
      case SEMICOLON:
      case AT:
        ;
        break;
      default:
        break label_46;
      }
      AnnotationTypeMemberDeclaration();
    }
    jj_consume_token(RBRACE);
  }

  final public void AnnotationTypeMemberDeclaration() throws ParseException {
   int modifiers;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case CLASS:
    case DOUBLE:
    case ENUM:
    case FINAL:
    case FLOAT:
    case INT:
    case INTERFACE:
    case LONG:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SHORT:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case IDENTIFIER:
    case AT:
      modifiers = Modifiers();
      if (jj_2_40(2147483647)) {
        Type();
        jj_consume_token(IDENTIFIER);
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case _DEFAULT:
          DefaultValue();
          break;
        default:
          ;
        }
        jj_consume_token(SEMICOLON);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
        case INTERFACE:
          ClassOrInterfaceDeclaration(modifiers);
          break;
        case ENUM:
          EnumDeclaration(modifiers);
          break;
        case AT:
          AnnotationTypeDeclaration(modifiers);
          break;
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
        case IDENTIFIER:
          FieldDeclaration(modifiers,null);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void DefaultValue() throws ParseException {
    jj_consume_token(_DEFAULT);
    MemberValue();
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_3R_198() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  final private boolean jj_3R_215() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_88()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_339()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_340()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_316() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_147()) return true;
    return false;
  }

  final private boolean jj_3R_176() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) return true;
    }
    return false;
  }

  final private boolean jj_3R_197() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  final private boolean jj_3R_299() {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_147()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_316()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_scan_token(45)) return true;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) return true;
    }
    return false;
  }

  final private boolean jj_3R_169() {
    if (jj_3R_176()) return true;
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_315() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_147()) return true;
    return false;
  }

  final private boolean jj_3R_214() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  final private boolean jj_3R_298() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_147()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_315()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_158() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  final private boolean jj_3R_213() {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_338() {
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  final private boolean jj_3R_212() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_338()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_278() {
    if (jj_3R_299()) return true;
    return false;
  }

  final private boolean jj_3R_277() {
    if (jj_3R_298()) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_337() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  final private boolean jj_3R_276() {
    if (jj_3R_85()) return true;
    return false;
  }

  final private boolean jj_3R_196() {
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  final private boolean jj_3R_211() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_337()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_195() {
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_175() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_276()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_277()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_278()) jj_scanpos = xsp;
    if (jj_3R_236()) return true;
    return false;
  }

  final private boolean jj_3R_240() {
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_336() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_234() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) return true;
    }
    return false;
  }

  final private boolean jj_3R_239() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_210() {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_336()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_357() {
    if (jj_3R_360()) return true;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_227() {
    if (jj_3R_234()) return true;
    return false;
  }

  final private boolean jj_3_28() {
    if (jj_3R_79()) return true;
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_scan_token(HOOK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_227()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_361() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) return true;
    }
    return false;
  }

  final private boolean jj_3_27() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_3R_84()) return true;
    return false;
  }

  final private boolean jj_3R_360() {
    if (jj_3R_204()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_361()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(STRICTFP)) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(31)) jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(TRANSIENT)) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(NATIVE)) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_scan_token(ABSTRACT)) return true;
    return false;
  }

  final private boolean jj_3R_359() {
    if (jj_3R_360()) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  final private boolean jj_3R_356() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_358()) {
    jj_scanpos = xsp;
    if (jj_3R_359()) return true;
    }
    return false;
  }

  final private boolean jj_3R_358() {
    if (jj_3R_173()) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  final private boolean jj_3R_201() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_97()) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(PROTECTED)) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(PUBLIC)) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_97()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_201()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GT)) return true;
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_3R_77()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_350() {
    if (jj_3R_357()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_254() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_1()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_35() {
    if (jj_3R_60()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_3R_77()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_349() {
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_348() {
    if (jj_3R_356()) return true;
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_335() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_348()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_349()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_350()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_334() {
    if (jj_3R_60()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_12()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_13()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_209() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_334()) {
    jj_scanpos = xsp;
    if (jj_3R_335()) return true;
    }
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_174()) return true;
    return false;
  }

  final private boolean jj_3_24() {
    if (jj_3R_76()) return true;
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_scan_token(SUPER)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_3R_158()) return true;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_3R_147()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_11()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_3R_75()) return true;
    Token xsp;
    if (jj_3_10()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_10()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_67() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    }
    return false;
  }

  final private boolean jj_3R_208() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_174()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_3R_158()) return true;
    return false;
  }

  final private boolean jj_3R_344() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_68()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_3R_75()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_3R_93()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_24()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) return true;
    }
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_75()) return true;
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_174()) return true;
    return false;
  }

  final private boolean jj_3R_325() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_60()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_275()) return true;
    return false;
  }

  final private boolean jj_3R_324() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_60()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_253()) return true;
    return false;
  }

  final private boolean jj_3R_343() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  final private boolean jj_3R_330() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_343()) {
    jj_scanpos = xsp;
    if (jj_3R_344()) return true;
    }
    return false;
  }

  final private boolean jj_3R_313() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3R_325()) return true;
    }
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) jj_scanpos = xsp;
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_333() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_174()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(THIS)) return true;
    if (jj_3R_66()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_314() {
    if (jj_3R_65()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_330()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_65()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) jj_scanpos = xsp;
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_66()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) return true;
    }
    return false;
  }

  final private boolean jj_3_22() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_60()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_scan_token(THIS)) return true;
    if (jj_3R_66()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_206() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_174()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_333()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_60()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_3R_151()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_60()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_285() {
    if (jj_3R_157()) return true;
    return false;
  }

  final private boolean jj_3R_284() {
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3_21() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_75()) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_3R_74()) return true;
    return false;
  }

  final private boolean jj_3R_312() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  final private boolean jj_3R_297() {
    if (jj_3R_314()) return true;
    return false;
  }

  final private boolean jj_3R_355() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_296() {
    if (jj_3R_313()) return true;
    return false;
  }

  final private boolean jj_3R_283() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_304()) return true;
    return false;
  }

  final private boolean jj_3R_346() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_354()) {
    jj_scanpos = xsp;
    if (jj_3R_355()) return true;
    }
    return false;
  }

  final private boolean jj_3R_354() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_311() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  final private boolean jj_3R_275() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_295()) {
    jj_scanpos = xsp;
    if (jj_3R_296()) {
    jj_scanpos = xsp;
    if (jj_3R_297()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_295() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_311()) {
    jj_scanpos = xsp;
    if (jj_3R_312()) return true;
    }
    if (jj_3R_253()) return true;
    return false;
  }

  final private boolean jj_3R_321() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_320()) return true;
    return false;
  }

  final private boolean jj_3R_347() {
    if (jj_3R_157()) return true;
    return false;
  }

  final private boolean jj_3R_281() {
    if (jj_3R_85()) return true;
    return false;
  }

  final private boolean jj_3R_269() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_281()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_282()) return true;
    xsp = jj_scanpos;
    if (jj_3R_283()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_284()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_285()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_229() {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_332() {
    if (jj_3R_346()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_347()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_310() {
    if (jj_scan_token(REM)) return true;
    return false;
  }

  final private boolean jj_3R_228() {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_205() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_332()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_326() {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  final private boolean jj_3R_320() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_326()) jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(121)) jj_scanpos = xsp;
    if (jj_3R_305()) return true;
    return false;
  }

  final private boolean jj_3R_274() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_3R_73()) return true;
    return false;
  }

  final private boolean jj_3R_267() {
    if (jj_3R_275()) return true;
    return false;
  }

  final private boolean jj_3R_266() {
    if (jj_3R_229()) return true;
    return false;
  }

  final private boolean jj_3R_309() {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  final private boolean jj_3R_265() {
    if (jj_3R_228()) return true;
    return false;
  }

  final private boolean jj_3R_303() {
    if (jj_3R_320()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_321()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_273() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  final private boolean jj_3R_253() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_264()) {
    jj_scanpos = xsp;
    if (jj_3R_265()) {
    jj_scanpos = xsp;
    if (jj_3R_266()) {
    jj_scanpos = xsp;
    if (jj_3R_267()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_264() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_273()) {
    jj_scanpos = xsp;
    if (jj_3R_274()) return true;
    }
    if (jj_3R_253()) return true;
    return false;
  }

  final private boolean jj_3R_263() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  final private boolean jj_3R_282() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_303()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_353() {
    if (jj_3R_69()) return true;
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_352() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  final private boolean jj_3R_294() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  final private boolean jj_3R_308() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  final private boolean jj_3R_292() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_308()) {
    jj_scanpos = xsp;
    if (jj_3R_309()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) return true;
    }
    }
    if (jj_3R_253()) return true;
    return false;
  }

  final private boolean jj_3R_351() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  final private boolean jj_3R_345() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_351()) {
    jj_scanpos = xsp;
    if (jj_3R_352()) {
    jj_scanpos = xsp;
    if (jj_3R_353()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_307() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_220() {
    if (jj_3R_65()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_345()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_249() {
    if (jj_3R_253()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_292()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_289() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_282()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_307()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_3R_229()) return true;
    return false;
  }

  final private boolean jj_3R_204() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_218() {
    if (jj_3R_228()) return true;
    return false;
  }

  final private boolean jj_3R_262() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_3R_72()) return true;
    return false;
  }

  final private boolean jj_3R_293() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  final private boolean jj_3R_291() {
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_272() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) return true;
    }
    if (jj_3R_249()) return true;
    return false;
  }

  final private boolean jj_3R_244() {
    if (jj_3R_249()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_272()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_203() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_261() {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  final private boolean jj_3R_290() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_304()) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(LSHIFT)) return true;
    return false;
  }

  final private boolean jj_3_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3_19()) return true;
    }
    }
    if (jj_3R_244()) return true;
    return false;
  }

  final private boolean jj_3R_238() {
    if (jj_3R_244()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_17()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_327() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_286()) return true;
    return false;
  }

  final private boolean jj_3R_288() {
    if (jj_3R_85()) return true;
    return false;
  }

  final private boolean jj_3R_246() {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3R_271() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_288()) jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    if (jj_3R_289()) return true;
    xsp = jj_scanpos;
    if (jj_3R_290()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_291()) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) return true;
    }
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_scan_token(ORASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_260() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  final private boolean jj_3R_252() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_260()) {
    jj_scanpos = xsp;
    if (jj_3R_261()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) {
    jj_scanpos = xsp;
    if (jj_3R_263()) return true;
    }
    }
    }
    if (jj_3R_238()) return true;
    return false;
  }

  final private boolean jj_3R_233() {
    if (jj_3R_238()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_252()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  final private boolean jj_3R_173() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_179()) jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    if (jj_3R_286()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_327()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_scan_token(XORASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_248() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(31)) jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_3R_175()) return true;
    return false;
  }

  final private boolean jj_3R_241() {
    if (jj_3R_63()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_5()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_3R_174()) return true;
    return false;
  }

  final private boolean jj_3R_226() {
    if (jj_3R_233()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_246()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_3R_173()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_157() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_241()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_scan_token(ANDASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_331() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_137() {
    if (jj_3R_157()) return true;
    return false;
  }

  final private boolean jj_3R_247() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  final private boolean jj_3R_243() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_247()) {
    jj_scanpos = xsp;
    if (jj_3R_248()) return true;
    }
    if (jj_3R_226()) return true;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_137()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_217() {
    if (jj_3R_226()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_243()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_63() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    }
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_3R_138()) return true;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(RUNSIGNEDSHIFTASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_237() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_217()) return true;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_174()) return true;
    return false;
  }

  final private boolean jj_3R_323() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_200() {
    if (jj_3R_217()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_237()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_305() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_323()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_scan_token(RSIGNEDSHIFTASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_232() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_200()) return true;
    return false;
  }

  final private boolean jj_3R_306() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_178() {
    if (jj_3R_200()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_232()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_202() {
    if (jj_scan_token(ASSERT)) return true;
    if (jj_3R_70()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_331()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_286() {
    if (jj_3R_305()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_306()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_scan_token(LSHIFTASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_225() {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_178()) return true;
    return false;
  }

  final private boolean jj_3R_171() {
    if (jj_3R_178()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_225()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_194() {
    if (jj_3R_215()) return true;
    return false;
  }

  final private boolean jj_3R_193() {
    if (jj_3R_214()) return true;
    return false;
  }

  final private boolean jj_3R_192() {
    if (jj_3R_213()) return true;
    return false;
  }

  final private boolean jj_3R_287() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_286()) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(MINUSASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_3R_212()) return true;
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_3R_211()) return true;
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_3R_210()) return true;
    return false;
  }

  final private boolean jj_3R_188() {
    if (jj_3R_209()) return true;
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_3R_208()) return true;
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_3R_207()) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_270() {
    if (jj_3R_60()) return true;
    if (jj_3R_286()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_287()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_scan_token(SC_AND)) return true;
    if (jj_3R_171()) return true;
    return false;
  }

  final private boolean jj_3R_185() {
    if (jj_3R_206()) return true;
    return false;
  }

  final private boolean jj_3R_184() {
    if (jj_3R_205()) return true;
    return false;
  }

  final private boolean jj_3R_183() {
    if (jj_3R_204()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_3R_171()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_216()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_182() {
    if (jj_3R_203()) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(PLUSASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_181() {
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_180() {
    if (jj_3R_202()) return true;
    return false;
  }

  final private boolean jj_3R_174() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_33() {
    if (jj_3R_80()) return true;
    return false;
  }

  final private boolean jj_3_40() {
    if (jj_3R_60()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_172() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_147()) return true;
    return false;
  }

  final private boolean jj_3R_199() {
    if (jj_scan_token(SC_OR)) return true;
    if (jj_3R_160()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_60()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_61()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_3R_85()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_251() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_scan_token(REMASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_150() {
    if (jj_3R_160()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_199()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_259() {
    if (jj_3R_271()) return true;
    return false;
  }

  final private boolean jj_3R_258() {
    if (jj_3R_270()) return true;
    return false;
  }

  final private boolean jj_3_39() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  final private boolean jj_3R_235() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_230() {
    Token xsp;
    if (jj_3R_235()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_235()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_138()) return true;
    return false;
  }

  final private boolean jj_3R_257() {
    if (jj_3R_269()) return true;
    return false;
  }

  final private boolean jj_3R_256() {
    if (jj_3R_268()) return true;
    return false;
  }

  final private boolean jj_3_31() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_255() {
    if (jj_3R_175()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(SLASHASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_83()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_39()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(84)) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_342() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_341()) return true;
    return false;
  }

  final private boolean jj_3R_250() {
    if (jj_3R_254()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) {
    jj_scanpos = xsp;
    if (jj_3R_258()) {
    jj_scanpos = xsp;
    if (jj_3R_259()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_30() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_221() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) return true;
    }
    return false;
  }

  final private boolean jj_3_32() {
    Token xsp;
    if (jj_3_30()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_30()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_31()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_3R_110()) return true;
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_3R_152()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_245() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3R_250()) {
    jj_scanpos = xsp;
    if (jj_3R_251()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_3R_84()) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_3R_150()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_177()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_242() {
    if (jj_3R_245()) return true;
    return false;
  }

  final private boolean jj_3R_341() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  final private boolean jj_3R_222() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_scan_token(STARASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_236() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_242()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_329() {
    if (jj_3R_341()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_342()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_328() {
    if (jj_3R_329()) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_scan_token(AT)) return true;
    if (jj_3R_81()) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_83()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_231() {
    if (jj_3R_236()) return true;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_147()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_172()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_scan_token(AT)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  final private boolean jj_3_38() {
    if (jj_scan_token(AT)) return true;
    if (jj_3R_81()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_scan_token(AT)) return true;
    if (jj_3R_81()) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_328()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_224() {
    if (jj_3R_66()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_231()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_37() {
    if (jj_scan_token(AT)) return true;
    if (jj_3R_81()) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) return true;
    }
    return false;
  }

  final private boolean jj_3R_223() {
    if (jj_3R_221()) return true;
    return false;
  }

  final private boolean jj_3R_134() {
    if (jj_3R_155()) return true;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_3R_154()) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_3R_161()) return true;
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_3R_153()) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_147()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_222()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) return true;
    }
    return false;
  }

  final private boolean jj_3R_111() {
    return false;
  }

  final private boolean jj_3R_318() {
    if (jj_3R_236()) return true;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_69()) return true;
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_78() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) return true;
    }
    return false;
  }

  final private boolean jj_3_29() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_75()) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_3R_110()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_322() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    return false;
  }

  final private boolean jj_3R_72() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == GT &&
                ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_111()) return true;
    if (jj_scan_token(GT)) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_135()) return true;
    return false;
  }

  final private boolean jj_3R_317() {
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_135()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_136()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GT)) return true;
    return false;
  }

  final private boolean jj_3R_301() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_300()) return true;
    return false;
  }

  final private boolean jj_3R_159() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == GT &&
                ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_112()) return true;
    if (jj_scan_token(GT)) return true;
    if (jj_scan_token(GT)) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_3R_70()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_159()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_319() {
    if (jj_3R_245()) return true;
    return false;
  }

  final private boolean jj_3R_300() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_317()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_318()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_302() {
    if (jj_scan_token(SEMICOLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_319()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_304() {
    if (jj_3R_81()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_322()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_280() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_300()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_301()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_302()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_94()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_340() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_279() {
    if (jj_3R_299()) return true;
    return false;
  }

  final private boolean jj_3R_268() {
    if (jj_scan_token(ENUM)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_279()) jj_scanpos = xsp;
    if (jj_3R_280()) return true;
    return false;
  }

  final private boolean jj_3R_339() {
    if (jj_scan_token(CATCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_320()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_15()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  public JavaParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;

  public JavaParser(java.io.InputStream stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new JavaParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public JavaParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new JavaParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public JavaParser(JavaParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(JavaParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error
  {
	private static final long serialVersionUID = 34;
  }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }



	public static String conv(String s)
	{
		// Añadido para permitir los signos '<' y '>' en strings
		s=s.replace("<","[[signomenos]]");
		s=s.replace(">","[[signomas]]");
	
		// Añadido para permitir caracteres basicos acentuados
		s=s.replace("á","[[a_acentuado]]");
		s=s.replace("é","[[e_acentuado]]");
		s=s.replace("í","[[i_acentuado]]");
		s=s.replace("ó","[[o_acentuado]]");
		s=s.replace("ú","[[u_acentuado]]");
		s=s.replace("Á","[[A_acentuado]]");
		s=s.replace("É","[[E_acentuado]]");
		s=s.replace("Í","[[I_acentuado]]");
		s=s.replace("Ó","[[O_acentuado]]");
		s=s.replace("Ú","[[U_acentuado]]");
		s=s.replace("ñ","[[n_sombrero]]");
		s=s.replace("Ñ","[[N_sombrero]]");
		s=s.replace("\"","[[comillas]]");
	
		return s;
	}
	
	public static String convReverse(String s)
	{
		// Añadido para permitir los signos '<' y '>' en strings
		s=s.replace("[[signomenos]]","<");
		s=s.replace("[[signomas]]",">");
	
		// Añadido para permitir caracteres basicos acentuados
		s=s.replace("[[a_acentuado]]","á");
		s=s.replace("[[e_acentuado]]","é");
		s=s.replace("[[i_acentuado]]","í");
		s=s.replace("[[o_acentuado]]","ó");
		s=s.replace("[[u_acentuado]]","ú");
		s=s.replace("[[A_acentuado]]","Á");
		s=s.replace("[[E_acentuado]]","É");
		s=s.replace("[[I_acentuado]]","Í");
		s=s.replace("[[O_acentuado]]","Ó");
		s=s.replace("[[U_acentuado]]","Ú");
		s=s.replace("[[n_sombrero]]","ñ");
		s=s.replace("[[N_sombrero]]","Ñ");
		s=s.replace("[[comillas]]","\"");
	
		return s;
	}
 
}
